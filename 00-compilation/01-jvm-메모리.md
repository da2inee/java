# JVM 구조와 메모리 영역

컴파일 과정 다음으로, **JVM이 .class를 어떻게 받아서 실행하는지**와 **메모리를 어떻게 쓰는지** 정리했습니다. 면접에서 "JVM 메모리 구조", "스택과 힙 차이" 자주 나옵니다.

---

## JVM 전체 구조 (한눈에)

```
┌─────────────────────────────────────────────────────────┐
│                      JVM (Java Virtual Machine)          │
│  ┌─────────────┐  ┌──────────────────┐  ┌────────────┐  │
│  │ 클래스 로더   │  │  실행 엔진        │  │  GC         │  │
│  │ (ClassLoader)│  │ (인터프리터/JIT)  │  │ (가비지     │  │
│  │              │  │                  │  │  컬렉터)     │  │
│  └──────┬──────┘  └────────┬─────────┘  └─────┬──────┘  │
│         │                  │                   │         │
│         ▼                  ▼                   ▼         │
│  ┌─────────────────────────────────────────────────────┐ │
│  │              런타임 데이터 영역 (메모리)               │ │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────────────┐   │ │
│  │  │ 메서드 영역 │  │   힙     │  │   스택 (스레드별)  │   │ │
│  │  │ (클래스 정보)│  │ (객체)   │  │   PC 레지스터    │   │ │
│  │  └──────────┘  └──────────┘  └──────────────────┘   │ │
│  └─────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────┘
```

- **클래스 로더**: .class를 로드해서 JVM 메모리에 올림  
- **실행 엔진**: 바이트코드를 해석/실행 (인터프리터 + JIT)  
- **GC**: 힙에서 쓰지 않는 객체 정리  
- **런타임 데이터 영역**: 실제로 코드·객체·변수가 쌓이는 메모리

---

## 런타임 데이터 영역 (메모리 3가지)

JVM이 프로그램 실행할 때 쓰는 메모리는 크게 세 가지로 나눕니다.

| 영역 | 저장하는 것 | 특징 |
|------|-------------|------|
| **메서드 영역** | 클래스 정보, static 변수, 상수 | 모든 스레드가 **공유**. JVM 시작 시 생성 |
| **힙(Heap)** | **객체**, 인스턴스 변수 | 모든 스레드가 **공유**. **GC 대상** |
| **스택(Stack)** | 메서드 호출 시 **지역 변수**, 매개변수, 리턴 주소 | **스레드마다 하나씩**. 메서드 끝나면 프레임 제거 |

면접에서 "스택과 힙 차이" 물어보면 → **스택은 메서드 실행·지역 변수**, **힙은 객체**라고 답하면 됩니다.

---

## 1. 메서드 영역 (Method Area)

- **저장하는 것**
  - 클래스 메타데이터 (이름, 필드, 메서드 정보)
  - **static 변수**
  - 상수 풀(Constant Pool) 일부
- **특징**
  - JVM이 시작될 때 생성되고, **모든 스레드가 공유**
  - 클래스 로더가 .class를 로드할 때 여기에 클래스 정보를 올림

**면접 포인트**: "static 변수는 어디에 저장되나요?" → **메서드 영역**

---

## 2. 힙(Heap)

- **저장하는 것**
  - **new로 생성한 객체**
  - 객체 안의 인스턴스 변수(필드)
- **특징**
  - **모든 스레드가 공유** → 멀티스레드에서 동기화 이슈가 나는 곳
  - **가비지 컬렉터(GC)**가 사용하지 않는 객체를 정리하는 영역
  - 크기가 크고, 객체 생명 주기가 제각각이라 GC가 필요함

**면접 포인트**: "객체는 어디에 저장되나요?" → **힙**  
"GC는 어떤 영역을 정리하나요?" → **힙**

---

## 3. 스택(Stack) — 스레드마다 하나

- **저장하는 것**
  - **메서드가 호출될 때마다** 하나의 **스택 프레임**이 쌓임
  - 그 안에 **지역 변수**, **매개변수**, **리턴 주소** 등
- **특징**
  - **스레드마다 스택이 하나씩** 있음 (스레드 간 공유 안 함)
  - 메서드가 **끝나면** 해당 프레임이 **pop** 되어 사라짐
  - 기본형(int, boolean 등) 변수는 **값 자체**가 스택에, **참조형**은 스택에 **참조(주소)**만 있고 실제 객체는 **힙**에 있음

**면접 포인트**: "지역 변수는 어디에 저장되나요?" → **스택**  
"스택과 힙의 차이?" → 스택 = 메서드 실행·지역 변수 / 힙 = 객체, GC 대상

---

## 스택 vs 힙 (면접용 정리)

| 구분 | 스택 | 힙 |
|------|------|-----|
| **저장** | 지역 변수, 매개변수, 메서드 프레임 | 객체(인스턴스) |
| **생명** | 메서드 종료 시 프레임 제거 | 객체는 GC가 수거할 때까지 |
| **공유** | 스레드마다 독립 | 모든 스레드 공유 |
| **GC** | 없음 (자동으로 pop) | GC가 정리 |

**예시**

```java
void method() {
    int a = 10;           // a(값 10) → 스택
    String s = "hi";      // s(참조) → 스택, "hi" 객체 → 힙
    Person p = new Person();  // p(참조) → 스택, Person 객체 → 힙
}
```

---

## PC 레지스터 (참고)

- **스레드마다 하나**
- 현재 실행 중인 **바이트코드 명령의 주소**를 가리킴
- 면접에서 깊게 안 물어보면 "각 스레드가 어디까지 실행했는지 저장" 정도만 알면 됨

---

## 정리 (면접 대답용)

1. **JVM 메모리 영역**  
   메서드 영역(클래스/static), 힙(객체), 스택(스레드별, 지역 변수·메서드 프레임).

2. **스택과 힙 차이**  
   스택 = 메서드 실행 단위·지역 변수, 메서드 끝나면 사라짐.  
   힙 = 객체가 살아 있는 곳, GC가 안 쓰는 객체 정리.

3. **객체 / static / 지역 변수 위치**  
   객체 → 힙, static → 메서드 영역, 지역 변수 → 스택(참조형은 스택에 주소만, 실제 객체는 힙).

다음 단계로 **GC(가비지 컬렉션)** 정리해두면 "힙을 누가 어떻게 정리하나"까지 이어져서 면접 대비하기 좋습니다.
