# 메서드 영역 / 힙 / 스택을 왜 나눠서 쓰나?

**한 줄**: 저장하는 것의 **성격**과 **살아 있는 기간**이 달라서, 나눠 두면 관리하기 쉽고 효율적이기 때문입니다.

---

## 예시로 보는 하나의 실행

```java
public class Cafe {
    static int totalCount = 0;   // static → 메서드 영역

    public static void main(String[] args) {
        Coffee c1 = new Coffee("아메리카노");   // 객체 → 힙
        Coffee c2 = new Coffee("라떼");        // 객체 → 힙
        int price = 4500;                      // 지역 변수 → 스택
        order(c1, price);                      // 메서드 호출 → 스택에 새 프레임
    }

    static void order(Coffee c, int p) {
        totalCount++;
        String msg = "주문: " + c.name;        // 지역 변수, 참조만 스택 / "주문:..." 객체는 힙
    }
}
```

---

## 1. 메서드 영역 – "클래스당 하나, 오래 살아남는 것"

**저장**: 클래스 정보(이름, 필드, 메서드 코드 등), **static 변수**

**왜 따로 두나?**

- **클래스는 한 번 로드되면** 그대로 쭉 씁니다. 인스턴스가 100개여도 **클래스 정보는 하나**면 됩니다.
- **static**은 **객체에 속한 게 아니라 클래스에 하나**만 있으면 되니까, 객체들이 모여 있는 **힙이랑 섞이면 안 됩니다**.

**예시**

- `Cafe` 클래스 로드 → 메서드 영역에 "Cafe 클래스 정보 + `totalCount`" 한 번만 올라감.
- `Coffee` 객체를 100개 만들어도, "Coffee 클래스 정보"는 메서드 영역에 **한 번만** 있음.

→ **"클래스·static 같은, 공용이고 오래 사는 것"** 전용 구역이라서 **메서드 영역**으로 분리.

---

## 2. 힙 – "객체들, 개수·크기·살아 있는 기간이 제각각"

**저장**: `new`로 만든 **객체** (인스턴스 변수 포함)

**왜 따로 두나?**

- 객체는 **개수도 많고**, **언제 만들어지고 언제 안 쓰이는지** 제각각입니다.
- **GC**가 "이건 이제 안 쓰이네" 하고 **골라서** 지워야 하니까, **객체만 모아두는 구역**이 있으면 GC가 그 구역만 보면 됩니다.
- 여러 스레드가 **같은 객체를 공유**할 수 있어서, "스레드마다 하나씩"인 **스택**이랑 섞이면 안 됩니다.

**예시**

- `new Coffee("아메리카노")` → 힙에 객체 하나.
- `new Coffee("라떼")` → 힙에 객체 하나 더.
- `order()` 끝나도 `c1`, `c2`가 main에서 아직 참조하면 **살아 있음**.
- 나중에 `c1 = null` 하면 그 아메리카노 객체는 **아무도 안 가리키니까** → GC가 **힙에서만** 찾아서 회수.

→ **"객체만 모아두고, GC가 그 구역만 정리"**하려고 **힙**을 따로 둠.

---

## 3. 스택 – "지금 실행 중인 메서드·지역 변수, 끝나면 바로 치우기"

**저장**: **메서드 호출마다** 하나의 **스택 프레임** (지역 변수, 매개변수, 리턴 주소 등)

**왜 따로 두나?**

- 메서드 **호출 순서**가 정해져 있습니다.  
  `main()` → `order()` 호출 → `order()` 끝나면 **그다음 다시 main()**으로.
- **끝난 메서드의 지역 변수는 더 이상 안 씁니다** → 그냥 **프레임 통째로 치우면** 됩니다. (GC 일일이 볼 필요 없음)
- **스레드마다** "지금 내가 어디서 뭘 호출했는지"가 다르니까, **스레드마다 스택 하나씩** 있어야 합니다.

**예시**

- `main()` 시작 → 스택에 **main 프레임** 쌓임 (지역 변수 `c1`, `c2`, `price` 등).
- `order(c1, price)` 호출 → 스택에 **order 프레임**이 그 위에 쌓임 (매개변수 `c`, `p`, 지역 변수 `msg` 등).
- `order()` 끝나면 → **order 프레임만** 통째로 **pop** → 그 안의 지역 변수는 자동으로 사라짐.
- 다시 **main 프레임**만 남음.

→ **"지금 실행 중인 메서드들만** LIFO로 쌓았다가, **끝나면 프레임만 떼어 내면** 끝"이라서 **스택**으로 분리.

---

## 한 번에 비교 (예시 기준)

| 구역 | 위 예시에서 저장되는 것 | 나누는 이유 |
|------|-------------------------|-------------|
| **메서드 영역** | `Cafe`/`Coffee` 클래스 정보, `totalCount` (static) | 클래스·static은 **하나만**, **오래** 유지 → 따로 관리 |
| **힙** | `Coffee("아메리카노")`, `Coffee("라떼")` 객체, 문자열 등 | 객체는 **많고**, **언제 죽는지** 제각각 → **GC가 이 구역만** 정리 |
| **스택** | `main`의 `c1`, `c2`, `price`, `order`의 `c`, `p`, `msg` (참조값/값) | **메서드 끝나면** 그 프레임만 **한 번에** 제거 → LIFO로 빠르게 치우기 좋음 |

---

## 안 나누면 생기는 일 (상상)

- **다 한 곳에** 넣었다고 치면:
  - "이건 메서드 끝났으니까 치우자" vs "이건 객체인데 아직 쓸 수 있나?"를 **한 메모리에서 다 구분**해야 하고,
  - GC가 **전체 메모리**를 다 스캔해야 해서 느려지고,
  - 스레드마다 "내 호출 스택"이랑 "공유 객체"가 섞여서 구조가 복잡해집니다.

그래서 **역할별로 나눠 두는 것** =  
메서드/클래스용(메서드 영역), 객체용(힙), "지금 실행 중인 메서드"용(스택)  
→ 관리·GC·멀티스레드 모두 처리하기 쉽게 하려는 이유입니다.
