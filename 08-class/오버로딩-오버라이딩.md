# 오버로딩 vs 오버라이딩

둘 다 **같은 이름**을 쓰는데, **어디서·뭘 다르게** 쓰는지가 다릅니다.

---

## 오버로딩 (Overloading)

- **같은 클래스 안**에서 **메소드 이름은 같고**, **매개변수 개수/타입만 다르게** 여러 개 두는 것.
- **컴파일 시점**에 "어떤 메소드를 부를지" 정해짐.

```java
public class Calculator {
    int add(int a, int b) {
        return a + b;
    }

    int add(int a, int b, int c) {
        return a + b + c;
    }

    double add(double a, double b) {
        return a + b;
    }
}

Calculator cal = new Calculator();
cal.add(1, 2);       // 3  → int add(int, int)
cal.add(1, 2, 3);    // 6  → int add(int, int, int)
cal.add(1.0, 2.0);   // 3.0 → double add(double, double)
```

→ **"이름은 같은데, 인자만 다르게 받는 여러 버전"** 이라고 보면 됨.

---

## 오버라이딩 (Overriding)

- **자식 클래스**에서 **부모 클래스에 있는 메소드**를 **같은 이름·같은 매개변수**로 **다시 정의**해서 **동작만 바꾸는** 것.
- **실행 시점**에 "실제 객체 타입"을 보고 어떤 메소드가 호출될지 정해짐 (다형성).

```java
class Animal {
    void speak() {
        System.out.println("...");
    }
}

class Dog extends Animal {
    @Override
    void speak() {
        System.out.println("멍멍");  // 부모 메소드 덮어씀
    }
}

class Cat extends Animal {
    @Override
    void speak() {
        System.out.println("야옹");
    }
}

Animal a = new Dog();
a.speak();  // "멍멍" → 실제 객체가 Dog라서 Dog의 speak() 실행
```

→ **"부모 메소드를 자식이 그대로 받아서, 내용만 다시 짜는 것"** 이라고 보면 됨.

---

## 한 줄로 비교

| 구분 | 오버로딩 | 오버라이딩 |
|------|----------|------------|
| **어디서** | 같은 클래스 안 | 자식 클래스에서 부모 메소드 |
| **뭘 다르게** | 매개변수 개수/타입 | 메소드 **몸통(동작)** |
| **이름** | 같음 | 같음 |
| **시점** | 컴파일 시 결정 | 실행 시 결정 (다형성) |
| **전제** | 없음 | 상속(extends) 필요 |

---

## 정리

- **오버로딩** = 같은 이름, **인자만 다른 여러 메소드** (한 클래스 안)
- **오버라이딩** = 부모 메소드를 **자식이 덮어써서 동작만 바꾸기** (상속 관계)

오버라이딩을 쓸 때는 **@Override** 를 붙여 두면, 부모에 그 메소드가 있는지 컴파일러가 확인해 줘서 실수 방지에 좋습니다.
