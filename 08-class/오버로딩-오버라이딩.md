# 오버로딩 vs 오버라이딩

둘 다 **같은 이름**을 쓰는데, **어디서·뭘 다르게** 쓰는지가 다릅니다.

---

## 오버로딩 (Overloading)

- **같은 클래스 안**에서 **메소드 이름은 같고**, **매개변수 개수/타입만 다르게** 여러 개 두는 것.
- **컴파일 시점**에 "어떤 메소드를 부를지" 정해짐.

```java
public class Calculator {
    int add(int a, int b) {
        return a + b;
    }

    int add(int a, int b, int c) {
        return a + b + c;
    }

    double add(double a, double b) {
        return a + b;
    }
}

Calculator cal = new Calculator();
cal.add(1, 2);       // 3  → int add(int, int)
cal.add(1, 2, 3);    // 6  → int add(int, int, int)
cal.add(1.0, 2.0);   // 3.0 → double add(double, double)
```

→ **"이름은 같은데, 인자만 다르게 받는 여러 버전"** 이라고 보면 됨.

- **매개변수 타입 순서**만 달라도 시그니처가 달라서 오버로딩이다.  
  예: `void add(int a, String b)` 와 `void add(String b, int a)` 는 서로 다른 메소드.

---

## 오버라이딩 (Overriding)

- **자식 클래스**에서 **부모 클래스에 있는 메소드**를 **같은 이름·같은 매개변수**로 **다시 정의**해서 **동작만 바꾸는** 것.
- "부모 메소드를 참조한다"보다 **"덮어쓴다(override)"**라고 표현하는 게 정확함.
- **실행 시점**에 "실제 객체 타입"을 보고 어떤 메소드가 호출될지 정해짐 (다형성).

```java
class Animal {
    void speak() {
        System.out.println("...");
    }
}

class Dog extends Animal {
    @Override
    void speak() {
        System.out.println("멍멍");  // 부모 메소드 덮어씀
    }
}

class Cat extends Animal {
    @Override
    void speak() {
        System.out.println("야옹");
    }
}

Animal a = new Dog();
a.speak();  // "멍멍" → 실제 객체가 Dog라서 Dog의 speak() 실행
```

→ **"부모 메소드를 자식이 그대로 받아서, 내용만 다시 짜는 것"** 이라고 보면 됨.

---

## 한 줄로 비교

| 구분 | 오버로딩 | 오버라이딩 |
|------|----------|------------|
| **어디서** | 같은 클래스 안 | 자식 클래스에서 부모 메소드 |
| **뭘 다르게** | 매개변수 개수/타입 | 메소드 **몸통(동작)** |
| **이름** | 같음 | 같음 |
| **시점** | 컴파일 시 결정 | 실행 시 결정 (다형성) |
| **전제** | 없음 | 상속(extends) 필요 |

---

## 정리

- **오버로딩** = 같은 이름, **인자만 다른 여러 메소드** (한 클래스 안)
- **오버라이딩** = 부모 메소드를 **자식이 덮어써서 동작만 바꾸기** (상속 관계)

---

## @Override는 꼭 써야 하나?

- **필수는 아니다.** 안 붙여도 오버라이딩은 되고, 컴파일·실행 모두 된다.
- **다만 붙여 두는 걸 권장한다.**
  - **실수 방지**: 부모에 없는 메소드를 오버라이드했다고 착각할 수 있다. `@Override`를 붙이면 컴파일러가 "부모에 이 메소드가 있나?"를 검사해서, 없으면 **컴파일 에러**로 알려 준다. (이름 오타, 시그니처 잘못 쓴 것 등을 바로 잡을 수 있음)
  - **의도 표현**: "이 메소드는 부모 메소드를 덮어쓴 것이다"라고 코드만 봐도 알 수 있다.

```java
class Parent { void run() { } }

class Child extends Parent {
    @Override
    void run() { }      // OK. 부모에 run() 있음

    @Override
    void runn() { }     // 컴파일 에러! 부모에 runn() 없음 → 오타 발견
}
```

→ 오버라이딩할 때마다 **@Override** 붙이는 습관을 두면 좋다.

---

## 추가로 알아두면 좋은 것

### 오버로딩

- **반환 타입만 다르고** 매개변수(이름·개수·타입·순서)가 같으면 **오버로딩이 아니다.**  
  컴파일러가 "어떤 메소드를 부를지" 매개변수로만 구분하기 때문에, 반환 타입만 다르면 **컴파일 에러**가 난다.  
  예: `int add(int a, int b)` 와 `double add(int a, int b)` → 에러.
- **생성자**도 같은 클래스 안에서 매개변수만 다르게 여러 개 두면 **생성자 오버로딩**이다.

### 오버라이딩

- **접근 제어자**: 자식에서 부모 메소드를 **더 좁게** 만들 수 없다.  
  부모가 `public`이면 자식은 `public`만 가능. `protected` → 자식은 `protected` 또는 `public`.
- **static 메소드**: `static` 메소드는 **오버라이딩이 아니라 숨김(hiding)**이다.  
  부모·자식 각각 자기 클래스 기준으로 호출된다. 다형성 적용 안 됨.
- **final 메소드**: 부모에서 `final`이 붙은 메소드는 **오버라이딩 불가**.
- **private 메소드**: `private`은 자식에게 상속되지 않으므로 **오버라이딩 대상이 아니다.**  
  자식에 같은 이름 메소드를 만들어도 그냥 자식만의 새 메소드일 뿐.
- **반환 타입**: 자식 메소드가 부모의 **반환 타입의 하위 타입**을 반환할 수 있다 (공변 반환 타입, Java 5+).  
  예: 부모 `Object clone()` → 자식 `MyClass clone()` 가능.
- **예외**: Checked 예외는 오버라이딩할 때 **부모보다 더 넓은 예외를 throws 하면 안 된다.**  
  같거나, 더 좁거나, 아예 안 던지거나만 가능.
